<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Steganography</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for file input */
        .file-input-btn {
            @apply block w-full text-sm text-slate-500
            file:mr-4 file:py-2 file:px-4
            file:rounded-full file:border-0
            file:text-sm file:font-semibold
            file:bg-blue-50 file:text-blue-700
            hover:file:bg-blue-100 cursor-pointer;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <div class="w-full max-w-2xl bg-white rounded-2xl shadow-xl p-8">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
            Image Steganography
        </h1>
        <p class="text-center text-gray-600 mb-8">
            Hide your secret messages inside an image.
        </p>

        <!-- Tabs -->
        <div class="border-b border-gray-200 mb-6">
            <nav class="flex -mb-px space-x-6" aria-label="Tabs">
                <button id="tab-encode"
                    class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-blue-600 text-blue-600">
                    Encode Message
                </button>
                <button id="tab-decode"
                    class="tab-btn whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300">
                    Decode Message
                </button>
            </nav>
        </div>

        <!-- Canvas for processing (hidden) -->
        <canvas id="processing-canvas" class="hidden"></canvas>

        <!-- Message Box (hidden) -->
        <div id="message-box" class="hidden fixed top-5 right-5 p-4 rounded-lg text-white shadow-md z-50">
            <span id="message-text"></span>
        </div>

        <!-- Encode Panel -->
        <div id="panel-encode">
            <div class="space-y-6">
                <div>
                    <label for="encode-image-input" class="block text-sm font-medium text-gray-700 mb-2">
                        1. Upload Your Image
                    </label>
                    <input id="encode-image-input" type="file" accept="image/png, image/jpeg" class="file-input-btn">
                    <img id="encode-preview" class="hidden mt-4 w-full h-auto rounded-lg shadow-inner border border-gray-200"
                        alt="Image preview" />
                </div>

                <div>
                    <label for="secret-message" class="block text-sm font-medium text-gray-700 mb-2">
                        2. Enter Your Secret Message
                    </label>
                    <textarea id="secret-message" rows="4"
                        class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Type your secret here..."></textarea>
                </div>

                <button id="encode-button"
                    class="w-full bg-blue-600 text-white py-3 px-6 rounded-lg font-bold text-lg hover:bg-blue-700 transition duration-300 shadow-md disabled:opacity-50">
                    Encode & Download Image
                </button>

                <!-- Download link will be populated by JS -->
                <a id="download-link"
                    class="hidden w-full bg-green-600 text-white text-center py-3 px-6 rounded-lg font-bold text-lg hover:bg-green-700 transition duration-300 shadow-md">
                    Click to Download
                </a>
            </div>
        </div>

        <!-- Decode Panel (hidden) -->
        <div id="panel-decode" class="hidden">
            <div class="space-y-6">
                <div>
                    <label for="decode-image-input" class="block text-sm font-medium text-gray-700 mb-2">
                        1. Upload Image to Decode
                    </label>
                    <input id="decode-image-input" type="file" accept="image/png, image/jpeg" class="file-input-btn">
                    <img id="decode-preview" class="hidden mt-4 w-full h-auto rounded-lg shadow-inner border border-gray-200"
                        alt="Image preview" />
                </div>

                <button id="decode-button"
                    class="w-full bg-blue-600 text-white py-3 px-6 rounded-lg font-bold text-lg hover:bg-blue-700 transition duration-300 shadow-md disabled:opacity-50">
                    Decode Message
                </button>

                <div>
                    <label for="decoded-message" class="block text-sm font-medium text-gray-700 mb-2">
                        Decoded Message:
                    </label>
                    <div id="decoded-message"
                        class="w-full p-4 bg-gray-50 border border-gray-200 rounded-lg min-h-[120px] whitespace-pre-wrap break-words font-mono text-gray-700">
                        ...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const tabEncode = document.getElementById('tab-encode');
            const tabDecode = document.getElementById('tab-decode');
            const panelEncode = document.getElementById('panel-encode');
            const panelDecode = document.getElementById('panel-decode');

            const encodeImageInput = document.getElementById('encode-image-input');
            const encodePreview = document.getElementById('encode-preview');
            const secretMessage = document.getElementById('secret-message');
            const encodeButton = document.getElementById('encode-button');
            const downloadLink = document.getElementById('download-link');

            const decodeImageInput = document.getElementById('decode-image-input');
            const decodePreview = document.getElementById('decode-preview');
            const decodeButton = document.getElementById('decode-button');
            const decodedMessageEl = document.getElementById('decoded-message');

            const canvas = document.getElementById('processing-canvas');
            const ctx = canvas.getContext('2d');

            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');

            // --- State ---
            let currentMode = 'encode';
            
            // This is a special string of bits to mark the end of our message
            const MESSAGE_DELIMITER = '1111111111111110'; // 16 bits

            // --- Tab Switching Logic ---
            tabEncode.addEventListener('click', () => switchTab('encode'));
            tabDecode.addEventListener('click', () => switchTab('decode'));

            function switchTab(mode) {
                if (currentMode === mode) return;
                currentMode = mode;

                if (mode === 'encode') {
                    // Show Encode Panel
                    panelEncode.classList.remove('hidden');
                    panelDecode.classList.add('hidden');
                    // Update Tab Styles
                    tabEncode.classList.add('border-blue-600', 'text-blue-600');
                    tabEncode.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                    tabDecode.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                    tabDecode.classList.remove('border-blue-600', 'text-blue-600');
                } else {
                    // Show Decode Panel
                    panelDecode.classList.remove('hidden');
                    panelEncode.classList.add('hidden');
                    // Update Tab Styles
                    tabDecode.classList.add('border-blue-600', 'text-blue-600');
                    tabDecode.classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                    tabEncode.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                    tabEncode.classList.remove('border-blue-600', 'text-blue-600');
                }
            }

            // --- Image Preview Logic ---
            encodeImageInput.addEventListener('change', (e) => showPreview(e, encodePreview));
            decodeImageInput.addEventListener('change', (e) => showPreview(e, decodePreview));

            function showPreview(event, previewElement) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        previewElement.src = e.target.result;
                        previewElement.classList.remove('hidden');
                    };
                    reader.readAsDataURL(file);
                }
            }

            // --- Show Message Box ---
            function showMessage(message, type = 'error') {
                messageText.textContent = message;
                if (type === 'error') {
                    messageBox.classList.add('bg-red-500');
                    messageBox.classList.remove('bg-green-500');
                } else {
                    messageBox.classList.add('bg-green-500');
                    messageBox.classList.remove('bg-red-500');
                }
                messageBox.classList.remove('hidden');
                setTimeout(() => {
                    messageBox.classList.add('hidden');
                }, 3000);
            }

            // --- Encoding Logic ---
            encodeButton.addEventListener('click', encodeMessage);

            function encodeMessage() {
                const file = encodeImageInput.files[0];
                const message = secretMessage.value;

                if (!file) {
                    return showMessage('Please upload an image first.');
                }
                if (!message) {
                    return showMessage('Please enter a secret message.');
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // 1. Draw image to canvas
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        // 2. Convert message to binary
                        const binaryMessage = textToBinary(message) + MESSAGE_DELIMITER;

                        // 3. Check if message fits
                        const maxBits = (img.width * img.height * 3); // 3 channels (R, G, B)
                        if (binaryMessage.length > maxBits) {
                            return showMessage(`Message is too long. Max ${Math.floor(maxBits / 8)} characters for this image.`);
                        }

                        // 4. Get pixel data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data; // This is a Uint8ClampedArray

                        // 5. Embed message bits into pixel data
                        let bitIndex = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            // Stop if message is fully embedded
                            if (bitIndex >= binaryMessage.length) break;

                            // We only use R, G, B channels (i, i+1, i+2). We skip Alpha (i+3).
                            
                            // R channel
                            data[i] = setLSB(data[i], binaryMessage[bitIndex++]);
                            if (bitIndex >= binaryMessage.length) break;

                            // G channel
                            data[i + 1] = setLSB(data[i + 1], binaryMessage[bitIndex++]);
                            if (bitIndex >= binaryMessage.length) break;

                            // B channel
                            data[i + 2] = setLSB(data[i + 2], binaryMessage[bitIndex++]);
                        }

                        // 6. Put modified data back on canvas
                        ctx.putImageData(imageData, 0, 0);

                        // 7. Create download link
                        // We MUST use PNG as it is lossless. JPEG is lossy and will corrupt the LSB data.
                        const newImageUrl = canvas.toDataURL('image/png');
                        downloadLink.href = newImageUrl;
                        downloadLink.download = 'encoded-image.png';
                        downloadLink.classList.remove('hidden');
                        
                        showMessage('Message encoded successfully!', 'success');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            // --- Decoding Logic ---
            decodeButton.addEventListener('click', decodeMessage);

            function decodeMessage() {
                const file = decodeImageInput.files[0];
                if (!file) {
                    return showMessage('Please upload an image to decode.');
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        // 1. Draw image to canvas
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);

                        // 2. Get pixel data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;

                        // 3. Extract LSBs until delimiter is found
                        let binaryMessage = '';
                        for (let i = 0; i < data.length; i += 4) {
                            // R channel
                            binaryMessage += getLSB(data[i]);
                            if (binaryMessage.endsWith(MESSAGE_DELIMITER)) break;

                            // G channel
                            binaryMessage += getLSB(data[i + 1]);
                            if (binaryMessage.endsWith(MESSAGE_DELIMITER)) break;

                            // B channel
                            binaryMessage += getLSB(data[i + 2]);
                            if (binaryMessage.endsWith(MESSAGE_DELIMITER)) break;
                        }

                        // 4. Check if delimiter was found
                        if (!binaryMessage.endsWith(MESSAGE_DELIMITER)) {
                            decodedMessageEl.textContent = 'No message found in this image.';
                            return showMessage('No hidden message found or image is corrupt.');
                        }

                        // 5. Remove delimiter and convert binary to text
                        const messageBits = binaryMessage.substring(0, binaryMessage.length - MESSAGE_DELIMITER.length);
                        
                        try {
                            const decodedText = binaryToText(messageBits);
                            decodedMessageEl.textContent = decodedText;
                            showMessage('Message decoded successfully!', 'success');
                        } catch (error) {
                            decodedMessageEl.textContent = 'Error during decoding.';
                            showMessage('Failed to parse message. Data may be corrupt.');
                        }
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            // --- Bitwise Helper Functions ---

            /**
             * Converts a string to its 8-bit binary representation.
             * e.g., "Hi" -> "0100100001101001"
             */
            function textToBinary(text) {
                return text.split('')
                    .map(char => char.charCodeAt(0).toString(2).padStart(8, '0'))
                    .join('');
            }

            /**
             * Converts a binary string back to text.
             * e.g., "0100100001101001" -> "Hi"
             */
            function binaryToText(binary) {
                return binary.match(/.{1,8}/g) // Split into 8-bit chunks
                    .map(byte => String.fromCharCode(parseInt(byte, 2)))
                    .join('');
            }

            /**
             * Sets the Least Significant Bit (LSB) of a number.
             * @param {number} value - The original number (0-255).
             * @param {string} bit - The bit to set ('0' or '1').
             * @returns {number} - The new number with the LSB modified.
             */
            function setLSB(value, bit) {
                if (bit === '1') {
                    return value | 1; // Bitwise OR with 1 (e.g., 1010 | 0001 = 1011)
                } else {
                    return value & ~1; // Bitwise AND with NOT 1 (e.g., 1011 & 1110 = 1010)
                }
            }

            /**
             * Gets the Least Significant Bit (LSB) of a number.
             * @param {number} value - The number (0-255).
             * @returns {string} - The LSB ('0' or '1').
             */
            function getLSB(value) {
                return (value & 1).toString(); // Bitwise AND with 1 (e.g., 1011 & 0001 = 1)
            }

        });
    </script>
</body>
</html>